<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏木的专栏</title>
  
  <subtitle>漠漠水田飞白鹭，阴阴夏木啭黄鹂，</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ohcat.xyz/"/>
  <updated>2018-07-16T00:10:09.689Z</updated>
  <id>http://blog.ohcat.xyz/</id>
  
  <author>
    <name>夏木</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJS 从入门到放弃</title>
    <link href="http://blog.ohcat.xyz/2018/07/16/Rxjs-from-entry-to-give-up/"/>
    <id>http://blog.ohcat.xyz/2018/07/16/Rxjs-from-entry-to-give-up/</id>
    <published>2018-07-15T23:51:48.000Z</published>
    <updated>2018-07-16T00:10:09.689Z</updated>
    
    <content type="html"><![CDATA[<p>RxJS 是实现响应式编程的库，因为官方文档不够清晰以及中文资料欠缺，再加上响应式编程本身的难度，导致学习曲线非常的陡峭。这篇文章稍微用简单和常见的 web 开发实例介绍下 RxJS 基础知识。</p><a id="more"></a><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>学习一个新库的第一手资料就是<a href="https://rxjs-dev.firebaseapp.com/" target="_blank" rel="noopener">官方文档</a>，但是当我粗略看完官方文档后，却连 hello world 都无法实现。下面我来回溯一下这个糟糕的历程：</p><ol><li><p>新建项目：<code>npm init</code></p></li><li><p>安装 parcel-bundler: <code>yarn add parcel-bundler -D</code></p></li><li><p>安装 RxJS: <code>yar</code></p></li><li><p><code>n add rxjs</code></p></li><li><p>添加 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"todo-val"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>添加 main.js , 复制文档上的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Rx <span class="keyword">from</span> <span class="string">'rxjs/Rx'</span>;</span><br><span class="line"></span><br><span class="line">Rx.Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>添加 npm script：<code>&quot;dev&quot;: &quot;parcel index.html&quot;</code></p></li><li><p>运行：<code>yarn dev</code></p><p><img src="http://static.ohcat.xyz/xnip2018-07-16-08-07-16-jpg(2018-07-16T08:07:55+08:00" alt="">.jpg)</p></li><li><p>浏览器查看(打开调试工具):</p><p><img src="http://static.ohcat.xyz/xnip2018-07-16-08-08-59-jpg(2018-07-16T08:09:13+08:00" alt="">.jpg)</p></li><li><p>放弃！</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJS 是实现响应式编程的库，因为官方文档不够清晰以及中文资料欠缺，再加上响应式编程本身的难度，导致学习曲线非常的陡峭。这篇文章稍微用简单和常见的 web 开发实例介绍下 RxJS 基础知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RxJS" scheme="http://blog.ohcat.xyz/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>规范 git commit message</title>
    <link href="http://blog.ohcat.xyz/2018/05/03/make-git-commit-message-specification/"/>
    <id>http://blog.ohcat.xyz/2018/05/03/make-git-commit-message-specification/</id>
    <published>2018-05-03T00:19:07.000Z</published>
    <updated>2018-05-03T00:45:32.209Z</updated>
    
    <content type="html"><![CDATA[<p>根据 Angular 建议的 git commit message 格式来规范化 git commit message，并自动校验。</p><a id="more"></a><h1 id="Commit-message-of-angular-config"><a href="#Commit-message-of-angular-config" class="headerlink" title="Commit message of angular config"></a>Commit message of angular config</h1><p>Git 每次提交代码，都要写 Commit message，但内容、格式并没有约束。目前，社区有多种 Commit message 的<a href="">写作规范</a>。而其中的 <a href="">Angular 规范</a>是目前使用最广的写法，且比较合理和系统化，并且有配套的工具 帮助编写和检查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 Angular 建议的 git commit message 格式来规范化 git commit message，并自动校验。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网页动效详解</title>
    <link href="http://blog.ohcat.xyz/2018/03/13/front-end-animation/"/>
    <id>http://blog.ohcat.xyz/2018/03/13/front-end-animation/</id>
    <published>2018-03-13T13:53:08.000Z</published>
    <updated>2018-05-03T00:14:11.916Z</updated>
    
    <content type="html"><![CDATA[<p>结合这段时间做小程序跳一跳动画的经验，整理相关的资料，梳理下知识脉络。同时理清那些还没有掌握的知识点，进阶的研究下 其他优秀的动画引擎实现和使用，稍微扩展下 3D 动画，游戏相关内容，篇幅字数 &gt; 5000，图片数 &gt; 10</p><a id="more"></a><h1 id="瞎扯淡"><a href="#瞎扯淡" class="headerlink" title="瞎扯淡"></a>瞎扯淡</h1><p>随着交互设计重要性的提升，动效也越来越被设计师所重视。它不仅仅是取悦用户的工具，而且被视作为改善用户体验的重要手段。从为界面营造氛围的微小动效，到用来沟通用户的视觉线索，动效所解决的问题越来越全面。<br>因此，对于前端开发而言，实现流畅的动效不仅是对技术的考验，也是对审美和思维的刺激。<br>网页动效 - 使网页元素呈现自然的变化。</p><h2 id="动效作用"><a href="#动效作用" class="headerlink" title="动效作用"></a>动效作用</h2><p><a href="http://www.uisdc.com/functional-motion-design-method" target="_blank" rel="noopener">用这4个超实用的方法，做出有价值的功能性动效！</a></p><h2 id="动效实例"><a href="#动效实例" class="headerlink" title="动效实例"></a>动效实例</h2><p>动效的分类非常多：<a href="http://www.uisdc.com/app-design-motion" target="_blank" rel="noopener">超全面！界面交互动效核心知识的分类与总结</a><br><a href="http://www.uisdc.com/product-animation-design-guide" target="_blank" rel="noopener">超全面！产品动效设计全方位科普手册</a></p><h1 id="网页动效实现技术方案"><a href="#网页动效实现技术方案" class="headerlink" title="网页动效实现技术方案"></a>网页动效实现技术方案</h1><p><a href="http://blog.csdn.net/zqjflash/article/details/44903859" target="_blank" rel="noopener">前端能力模型-动画类型及动画库的介绍</a></p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>transition, animation，逐帧动画，keyframe(关键帧)<br><a href="https://zhuanlan.zhihu.com/p/20844840" target="_blank" rel="noopener">CSS3动画之逐帧动画</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">CSS动画简介</a></p><ul><li>animation 实例<iframe height="265" scrolling="no" title="Watson-Avatar-Purple-v1" src="//codepen.io/xiamu/embed/KzjzpG/?height=265&theme-id=light&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/xiamu/pen/KzjzpG/" target="_blank" rel="noopener">Watson-Avatar-Purple-v1</a> by Ben (<a href="https://codepen.io/xiamu" target="_blank" rel="noopener">@xiamu</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe></li></ul><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>RAF，缓动函数，帧速率<br><a href="http://blog.csdn.net/cwzhsi/article/details/52206575" target="_blank" rel="noopener">高中物理学运动公式实现js动画</a><br><a href="http://djt.qq.com/article/view/1538" target="_blank" rel="noopener">如何让你的动画更自然—— 运动曲线探究与应用</a></p><ul><li>自然的动画<iframe height="265" scrolling="no" title="VelocityJS demo" src="//codepen.io/xiamu/embed/MrxejV/?height=265&theme-id=dark&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/xiamu/pen/MrxejV/" target="_blank" rel="noopener">VelocityJS demo</a> by Ben (<a href="https://codepen.io/xiamu" target="_blank" rel="noopener">@xiamu</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe></li></ul><h2 id="svg-补充"><a href="#svg-补充" class="headerlink" title="svg(补充)"></a>svg(补充)</h2><p><a href="https://aotu.io/notes/2017/01/22/snapsvg/index.html" target="_blank" rel="noopener">使用 Snap.svg 制作动画</a></p><ul><li>矢量动画<iframe height="265" scrolling="no" title="SVG Path animated Text" src="//codepen.io/Zaku/embed/ALChE/?height=265&theme-id=light&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/Zaku/pen/ALChE/" target="_blank" rel="noopener">SVG Path animated Text</a> by Tamino Martinius (<a href="https://codepen.io/Zaku" target="_blank" rel="noopener">@Zaku</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><h2 id="canvas-补充"><a href="#canvas-补充" class="headerlink" title="canvas(补充)"></a>canvas(补充)</h2><h2 id="webgl-补充"><a href="#webgl-补充" class="headerlink" title="webgl(补充)"></a>webgl(补充)</h2><h1 id="动效的物理原理"><a href="#动效的物理原理" class="headerlink" title="动效的物理原理"></a>动效的物理原理</h1>自然的动画效果应该和现实生活中看到的物体运动轨迹是相似的。这样的效果其物理原理都是运动曲线函数，如小球下落是匀加速函数 :<br>$$<br>s1 = 1/2 <em> g </em> t^2<br>$$<br>如果将空气阻力和接触面材质的影响考虑进来，那么小球的回弹高度可以用下面公式表达：$s2=s1*n$ (0&lt;n&lt;1)。如此循环，直至小球最终停在地上，这样就可以模拟出整个小球掉下的效果。</li></ul><p>现实生活中的运动效果丰富多样，只靠css3提供的几个基本动画函数是不足以模拟的。如果要模拟出真实的效果，就需要理解这些效果背后的运动函数。</p><h3 id="弹簧动画的运动曲线"><a href="#弹簧动画的运动曲线" class="headerlink" title="弹簧动画的运动曲线"></a>弹簧动画的运动曲线</h3><p>现在我们以常见的弹簧动画而例来说明下怎样模拟出这个效果：<br>下面有一个弹簧块，假设它质量为1，在它不动的时候位置是 $x = 1$，则拉伸时的距离就是 $x-1$。</p><p>将这比作一个动画，弹簧块在时间 t 时所处的位置 x 就可以看作动画曲线函数 $x = f(t)$。然后我们求出这个函数的公式，就可以模拟出这个动画效果了。</p><p>关于时间从 0 ~ 1，以及 raf 的应用，最终实现一个弹簧动画。</p><h2 id="模拟自然世界"><a href="#模拟自然世界" class="headerlink" title="模拟自然世界"></a>模拟自然世界</h2><h1 id="动效的数学原理"><a href="#动效的数学原理" class="headerlink" title="动效的数学原理"></a>动效的数学原理</h1><h2 id="缓动函数"><a href="#缓动函数" class="headerlink" title="缓动函数"></a>缓动函数</h2><h1 id="动效实现库"><a href="#动效实现库" class="headerlink" title="动效实现库"></a>动效实现库</h1><p>tween.js，dynamics.js，anime.js，animation.css，velocity.js</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合这段时间做小程序跳一跳动画的经验，整理相关的资料，梳理下知识脉络。同时理清那些还没有掌握的知识点，进阶的研究下 其他优秀的动画引擎实现和使用，稍微扩展下 3D 动画，游戏相关内容，篇幅字数 &amp;gt; 5000，图片数 &amp;gt; 10&lt;/p&gt;
    
    </summary>
    
    
      <category term="动效，canvas ， js 动画" scheme="http://blog.ohcat.xyz/tags/%E5%8A%A8%E6%95%88%EF%BC%8Ccanvas-%EF%BC%8C-js-%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>hexo-skill</title>
    <link href="http://blog.ohcat.xyz/2018/02/28/hexo-skill/"/>
    <id>http://blog.ohcat.xyz/2018/02/28/hexo-skill/</id>
    <published>2018-02-28T05:32:17.000Z</published>
    <updated>2018-05-03T00:14:11.916Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 使用技巧整理<br><a id="more"></a></p><h1 id="hexo-new-后同步打开文章编辑器"><a href="#hexo-new-后同步打开文章编辑器" class="headerlink" title="hexo new 后同步打开文章编辑器"></a>hexo new 后同步打开文章编辑器</h1><p>Hexo 使用 <code>hexo new &quot;post-name&quot;</code> 以后，自动使用编辑器打开文件。</p><h2 id="step1-安装-shelljs模块，实现自动部署加载JS脚本"><a href="#step1-安装-shelljs模块，实现自动部署加载JS脚本" class="headerlink" title="step1 安装 shelljs模块，实现自动部署加载JS脚本"></a>step1 安装 shelljs模块，实现自动部署加载JS脚本</h2><p><code>npm install --save-dev shelljs</code></p><h2 id="step2-添加自动脚本"><a href="#step2-添加自动脚本" class="headerlink" title="step2 添加自动脚本"></a>step2 添加自动脚本</h2><p>根目录下新建 ‘scripts’ 文件夹，然后新建文件 ‘open-new.js’。文件内容如下：<br><code>const exec = require(&#39;child_process&#39;).exec;// Hexo 3.xhexo.on(&#39;new&#39;, function (data) {    exec(</code>open -a /Applications/Typora.app ${data.path}<code>);});</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 使用技巧整理&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.ohcat.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发经验(一)</title>
    <link href="http://blog.ohcat.xyz/2018/02/28/wapp-bug-record/"/>
    <id>http://blog.ohcat.xyz/2018/02/28/wapp-bug-record/</id>
    <published>2018-02-28T02:40:22.000Z</published>
    <updated>2018-05-03T00:14:11.917Z</updated>
    
    <content type="html"><![CDATA[<p>小程序跳坑指南☂️<br><a id="more"></a></p><h1 id="小程序开发经验"><a href="#小程序开发经验" class="headerlink" title="小程序开发经验"></a>小程序开发经验</h1><h2 id="hidden-无效"><a href="#hidden-无效" class="headerlink" title="hidden 无效"></a>hidden 无效</h2><p>因为 <code>hidden</code> 属性其实是使用 <code>display:none</code> 来隐藏的，当添加了 hidden 属性的元素同时在 wxss 中添加了 <code>display:flex</code> 等就会无效。解决方案：可以通过控制 class 来显示隐藏。</p><h2 id="canvas、textarea、video层级最高"><a href="#canvas、textarea、video层级最高" class="headerlink" title="canvas、textarea、video层级最高"></a>canvas、textarea、video层级最高</h2><h3 id="为什么-canvas、textarea、video-层级最高？"><a href="#为什么-canvas、textarea、video-层级最高？" class="headerlink" title="为什么 canvas、textarea、video 层级最高？"></a>为什么 canvas、textarea、video 层级最高？</h3><p>—— ”小程序视图层仍然依赖于Webview，只有部分组件是原生组件，用来解决Mobile Web体验问题。目前原生组件包括：input，textarea，video，map，canvas。<br>tip: input 组件是一个 native 组件，字体是系统字体，所以无法设置 font-family；<br>tip: textarea 组件是由客户端创建的原生组件，它的层级是最高的。<br>tip: video 组件是由客户端创建的原生组件，它的层级是最高的。<br>tip: map 组件是由客户端创建的原生组件，它的层级是最高的。<br>tip: canvas 组件是由客户端创建的原生组件，它的层级是最高的。<br>而其它组件都是基于Web Component规范实现的Custom Element，而诸如picker弹出选择器行为，navigator跳转行为，都是基于微信原生提供的能力，理解为调用wx.xxxApi”</p><h3 id="对前端造成的困惑："><a href="#对前端造成的困惑：" class="headerlink" title="对前端造成的困惑："></a>对前端造成的困惑：</h3><p>无法使用 z-index 控制层级显示</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>使用 hidden 属性控制隐藏显示</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.wxapp-union.com/forum.php?mod=forumdisplay&amp;fid=2&amp;filter=typeid&amp;typeid=3" target="_blank" rel="noopener">小程序社区</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序跳坑指南☂️&lt;br&gt;
    
    </summary>
    
    
      <category term="小程序，bug" scheme="http://blog.ohcat.xyz/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cbug/"/>
    
  </entry>
  
  <entry>
    <title>async/await 应用手札</title>
    <link href="http://blog.ohcat.xyz/2017/12/12/async-await-tutorial/"/>
    <id>http://blog.ohcat.xyz/2017/12/12/async-await-tutorial/</id>
    <published>2017-12-12T02:54:27.000Z</published>
    <updated>2018-05-03T00:14:11.916Z</updated>
    
    <content type="html"><![CDATA[<p>[注：以下代码都在支持 Promise 的 Node 环境中实现]<br><a id="more"></a></p><h1 id="1-promise-释义"><a href="#1-promise-释义" class="headerlink" title="1 promise 释义"></a>1 promise 释义</h1><p>promise 是抽象异步处理的<strong>对象</strong>，其提供了一系列处理异步操作的方法。</p><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 异步操作</span></span><br><span class="line"><span class="comment">// 操作结束，使用 resolve()返回结果；使用 reject()处理错误</span></span><br><span class="line">&#125;)</span><br><span class="line">promiseA.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><p>例子1-1：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'3秒后返回了A'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promiseA.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="1-2-static-method"><a href="#1-2-static-method" class="headerlink" title="1.2 static method"></a>1.2 static method</h2><p>像 <code>Promise</code> 这样的全局对象还拥有一些静态方法。</p><p>包括 <code>Promise.all()</code> 还有 <code>Promise.resolve()</code> 等在内，主要都是一些对Promise进行操作的辅助方法。</p><h3 id="1-2-1-Promise-all"><a href="#1-2-1-Promise-all" class="headerlink" title="1.2.1 Promise.all"></a>1.2.1 Promise.all</h3><p><code>Promise.all</code> 接收一个<code>promise</code>对象数组作为参数，当这个数组里的所有<code>promise</code>对象全部变为<code>resolve</code>或<code>reject</code>状态的时候，它才会去调用<code>.then</code>方法。<br>用于需要同时触发多个异步操作，并在所有异步操作都执行结束以后才调用<code>.then</code>。<br><code>Promise.all</code> 里有一个 <code>promise</code> 返回错误的时候就调用 <code>catch()</code> 了。测试代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise A.'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseB = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error B'</span>);</span><br><span class="line">    <span class="comment">// resolve('promise B');</span></span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseC = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'error c'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promiseA, promiseB, promiseC]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果：error c</span></span><br></pre></td></tr></table></figure></p><p>这点和预期的不同。具体描述可以看 MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">文档</a>，这里摘录一部分：</p><blockquote><p>The <code>Promise.all()</code> method returns a single <code>Promise</code> that resolves when all of the promises in the iterable argument have resolved or when the iterable argument contains no promises. It rejects with the reason of the first promise that rejects.</p></blockquote><ul><li>思考：那么在并行执行所有 <code>promise</code>过程中，在存在 <code>reject</code> 的情况下如何获取其余 <code>resolve</code> 的全部结果？<br>似乎并没有单独的 <code>method</code>来处理，需要封装一个方法。<br>###1.2.2 Promise.resolve<br>静态方法<code>Promise.resolve(value)</code>可以认为是<code>new Promise()</code>方法的快捷方式。如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>但初始化<code>Promise</code>对象建议仍然使用<code>new Promise</code>，<code>Promise.resove</code>的另一个作用是将<code>thenable</code>对象转换为<code>promise</code>对象。<br><a href="https://github.com/w3ctag/promises-guide" target="_blank" rel="noopener">ES6 Promise</a>里提到了<code>Thenable</code>的概念，简单来讲它是非常类似于<code>promise</code>的东西。就好像有些具有<code>.length</code>方法的非数组对象被称为<code>Array like</code>，<code>thenable</code>指的是具有<code>.then</code>方法的对象。<br>这种将<code>thenable</code>对象转换为<code>promise</code>对象的机制要求<code>thenable</code>对象所拥有的<code>then</code>方法应该和<code>Promise</code>所拥有的<code>then</code> 方法具有同样的功能和处理过程，在将<code>thenable</code>对象转换为<code>promise`</code>对象的时候，还会巧妙的利用thenable<code>对象原来具有的</code> then <code>方法。最简单的例子就是</code>jQuery.ajax()<code>，它的返回值就是</code>thenable<code>。下面看看如何将</code>thenable<code>对象转换为</code>promise`对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>)); <span class="comment">// =&gt; promise 对象</span></span><br><span class="line">promiseA.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是<code>jQuery.ajax()</code>返回的是一个具有<code>.then</code>方法的<code>jqXHR Object</code>对象，这个对象继承了来自<code>Deferred Object</code>的方法和属性。<br>但是<code>Deferred Object</code>并没有遵循<code>PormisesA+</code>或<code>ES6 Promises</code>标准，所以即使看上去对象转换为了<code>promise</code>对象，其实还是缺失了部份信息。即使一个对象具有<code>.then</code>方法，也不一定就能作为<code>ES6 Promises</code>对象使用。<br>这种转换 <code>thenable</code>的功能除了在编写使用<code>Promises</code>的类库的时候需要了解之外，通常作为<code>end-user</code>不会使用到此功能。</p><p>###1.2.3 Promise.race<br><code>Promise.race</code>和<code>Promise.all</code>类似，同样对多个<code>promise</code>对象进行处理，同样接收一个promise对象数组。<code>Promise.race</code>只要有一个<code>promise</code>对象进入<code>Fullfilled</code>或者<code>Rejected</code>状态的话，就会执行<code>.then</code>或<code>.catch</code>方法。<br>测试代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise A.'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseB = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// reject('error B');</span></span><br><span class="line">    resolve(<span class="string">'promise B'</span>);</span><br><span class="line">  &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseC = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// reject('error c');</span></span><br><span class="line">    resolve(<span class="string">'promise c'</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promiseA, promiseB, promiseC]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="1-2-4-Promise-reject"><a href="#1-2-4-Promise-reject" class="headerlink" title="1.2.4 Promise.reject"></a>1.2.4 Promise.reject</h3><p>通过调用<code>Promise.reject()</code>可以将错误对象传递给<code>onRejected</code> 函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"BOOM!"</span>))</span><br><span class="line">.catch((error))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法并不常用。</p><h2 id="1-3-promise-状态"><a href="#1-3-promise-状态" class="headerlink" title="1.3 promise 状态"></a>1.3 promise 状态</h2><p>用 <code>new Promise</code>实例化的 promise 对象有三种状态：</p><ul><li>‘has resolution’ =&gt; ‘Fulfilled’<br>resolve(成功)时，会调用 onFulfilled。</li><li>‘has rejected’ =&gt; ‘Rejected’<br>reject(失败)时，会调用 onRejected。</li><li>‘unresolved’ =&gt; ‘Pending’<br>promise 对象刚被创建后的初始状态。</li></ul><p>promise对象的状态，从 Pending 转换为 Fulfilled 或 Rejected 之后，promise 对象的状态就不再改变。因此，在 <code>.then()</code>内执行的函数只会调用一次。</p><h2 id="异常处理：then-or-catch"><a href="#异常处理：then-or-catch" class="headerlink" title="异常处理：then or catch?"></a>异常处理：then or catch?</h2><p><code>.catch</code> 方法可以理解为 <code>promise.then(undefined, onRejected)</code>。但两者有不同之处：</p><ol><li>使用promise.then(onFulfilled, onRejected) 的话，在 onFulfilled 中发生异常的话，在 onRejected 中是捕获不到这个异常的。</li><li>在 promise.then(onFulfilled).catch(onRejected) 的情况下，then 中产生的异常能在 .catch 中捕获。</li><li>then 和 .catch 在本质上是没有区别的，但需要根据1，2点的差异选择适用的场合。<br>测试对比代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'1s test.'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseA.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'handler err'</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`promiseA <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'1s test.'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseA.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'handler err'</span>);</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`promiseA <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="2-async-await-简介"><a href="#2-async-await-简介" class="headerlink" title="2 async/await 简介"></a>2 async/await 简介</h1><p>Node7 通过 <code>--harmony_async_await</code>参数支持 async/await ，而 async/await 由于其可以用同步形式的代码书写异步操作，能彻底杜绝‘回调地狱’式代码。<br>async/await 基于 <code>Promise</code>, 是 <code>Generator</code> 函数的语法糖。<code>async</code> 函数返回一个 <code>Promise</code> 对象，可以使用 <code>then</code> 方法添加回调函数。当函数执行时，一旦遇到<code>await</code>就先返回，等到触发的异步操作完成，再接着执行函数体后面的语句。示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asynchornous</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'测试 async/await'</span>);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time0 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> asynchornous(<span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">const</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`返回 =&gt; <span class="subst">$&#123;res&#125;</span>,用时：<span class="subst">$&#123;<span class="built_in">Math</span>.floor((time1 - time0)<span class="regexp">/1000)&#125;s`);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">test();</span></span></span></span><br></pre></td></tr></table></figure></p><h2 id="2-1-await-的用法"><a href="#2-1-await-的用法" class="headerlink" title="2.1 await 的用法"></a>2.1 await 的用法</h2><p><code>await</code> 命令必须用到 <code>async</code> 函数中，且其后应该是一个 <code>Promise</code> 对象。如果不是，会被转化为一个立即 <code>resolve</code> 的 <code>Promise</code> 对象。<br>只要一个 <code>await</code>命令后面的 <code>Promise</code> 对象变为 <code>reject</code> 状态，那么整个 <code>async</code> 函数都会中断执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'test'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时如果我们希望前一个异步操作失败后，不中断后面的异步操作，可以捕获前一个异步操作的错误。另一种写法是在 <code>await</code>后面的 <code>Promise</code> 对象后再跟上 <code>catch</code>方法。示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">`test`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// test</span></span><br></pre></td></tr></table></figure></p><h2 id="2-2-捕获错误"><a href="#2-2-捕获错误" class="headerlink" title="2.2 捕获错误"></a>2.2 捕获错误</h2><p><code>await</code> 命令后的 <code>Promise</code>对象，运行结果可能是 rejected，这样等同于 <code>async</code>函数返回的 <code>Promise</code> 状态为 <code>rejected</code>。 所以可以把 await 命令放到 try…catch 代码中。示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asynchornous</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve('测试 async/await');</span></span><br><span class="line">      reject(<span class="string">'error test'</span>);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time0 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">'...'</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = <span class="keyword">await</span> asynchornous(<span class="number">2000</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`返回 =&gt; <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> time1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`返回 =&gt; <span class="subst">$&#123;res&#125;</span>,用时：<span class="subst">$&#123;<span class="built_in">Math</span>.floor((time1 - time0)<span class="regexp">/1000)&#125;s`);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">test();</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">/</span><span class="regexp">/ 执行后返回结果如下：</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">/</span><span class="regexp">/ 返回 =&gt; error test</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">/</span><span class="regexp">/ 返回 =&gt; ...,用时：2s</span></span></span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-并发执行"><a href="#2-3-并发执行" class="headerlink" title="2.3 并发执行"></a>2.3 并发执行</h2><p>如果 多个 <code>await</code> 后面的异步操作，不存在依赖关系，那么最好让它们都并发执行。使用 <code>Promise.all</code> 可以让多个 <code>promise</code> 并发，同时还有另一种写法。<br>示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [resA, resB] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([testA(), testB]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> proA = testA();</span><br><span class="line"><span class="keyword">let</span> proB = testB();</span><br><span class="line"><span class="keyword">let</span> resA = <span class="keyword">await</span> proA;</span><br><span class="line"><span class="keyword">let</span> resB = <span class="keyword">await</span> proB;</span><br></pre></td></tr></table></figure></p><p>上述写法，testA 和 testB 都是同时触发的。那么再看看继发执行的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resA = <span class="keyword">await</span> proA();</span><br><span class="line"><span class="keyword">let</span> resB = <span class="keyword">await</span> proB();</span><br></pre></td></tr></table></figure></p><h1 id="3-改写-callback-方式"><a href="#3-改写-callback-方式" class="headerlink" title="3 改写 callback 方式"></a>3 改写 callback 方式</h1><p>Node 很多库函数，还有很多第三方库函数都是使用回调实现，那么要如何修改为 Promise 实现？</p><ol><li>使用第三方库，如：Async，Q，Bluebird 等，具体实现请参考官方文档和附录参考3。</li><li>自己实现一个将回调风格转变为 Promise 风格的类库。<br>这里详细讲解如何实现回调函数的转换函数。<h2 id="3-1-定义-promisify"><a href="#3-1-定义-promisify" class="headerlink" title="3.1 定义 promisify()"></a>3.1 定义 promisify()</h2><code>promisify</code> 是一个转换函数，它的参数是需要转换的回调函数，那么返回值则是一个返回 <code>promise</code>对象的函数。如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> </span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-Promise-中调用-callback"><a href="#3-2-Promise-中调用-callback" class="headerlink" title="3.2 Promise 中调用 callback"></a>3.2 Promise 中调用 callback</h2><p>要让回调函数在 Promise 中调用，并且根据结果适当的调用<code>resolve()</code>和<code>reject()</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      callbacn(<span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，Node 回调函数第一个参数都是错误对象，如果为 null 表示没有错误。</p><h2 id="3-3-添加参数"><a href="#3-3-添加参数" class="headerlink" title="3.3 添加参数"></a>3.3 添加参数</h2><p>继续添加处理参数的代码。Node 回调函数通常前面 n 个参数是内部实现需要使用的参数，而最后一个参数是回调函数。因此可以使用 ES6 的可变参数和扩展数据语法来实现。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">      callback(...args, (error, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-4-实现-promisifyObject"><a href="#3-4-实现-promisifyObject" class="headerlink" title="3.4 实现 promisifyObject()"></a>3.4 实现 <code>promisifyObject()</code></h2><p>顾名思义，<code>promisifyObject()</code> 是用来转换对象中异步方法的回调函数。转换函数必须考虑<code>this</code> 指针的问题，所以不能直接使用上面的一般实现。下面是 <code>promisify()</code> 的简化实现，详情请参考代码中的注释。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyObject</span>(<span class="params">obj, suffx = <span class="string">'Promisified'</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参照之前的实现，重新实现 promisify.</span></span><br><span class="line">  <span class="comment">// 这个函数没用到外层的局部变量，不必实现局域函数</span></span><br><span class="line">  <span class="comment">// 这里实现为局部函数只是为了组织演示代码</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意调用的方式有了改变</span></span><br><span class="line">        callback.call(<span class="keyword">this</span>, ...args, (error, result) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先找出所有方法名称</span></span><br><span class="line">  <span class="comment">// 如果需要过滤可以添加 filter 实现</span></span><br><span class="line">  <span class="keyword">const</span> keys = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      keys.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将转换之后的函数仍然附加到原对象上，</span></span><br><span class="line">  <span class="comment">// 以确保调用时候，this 引用正确。。</span></span><br><span class="line">  <span class="comment">// 为了避免覆盖原函数，`promise`风格的函数名前添加‘suffix’.</span></span><br><span class="line">  keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    obj[<span class="string">`<span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;suffix&#125;</span>`</span>] = promisify(obj[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-5-将转换-Promise-的函数封装成模块"><a href="#3-5-将转换-Promise-的函数封装成模块" class="headerlink" title="3.5 将转换 Promise 的函数封装成模块"></a>3.5 将转换 <code>Promise</code> 的函数封装成模块</h2><p>实现很简单，具体代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  promisify,</span><br><span class="line">  promisifyObjecj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过解构对象导入</span></span><br><span class="line"><span class="comment">// const &#123;promisify, promisifyObject&#125; = require('./promisify');</span></span><br></pre></td></tr></table></figure></p><h2 id="3-6-实际场景应用"><a href="#3-6-实际场景应用" class="headerlink" title="3.6 实际场景应用"></a>3.6 实际场景应用</h2><p>这里使用实际项目中用到的 qiniu api 存图场景中异步回调被改写后如何使用 <code>async/await</code>，示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveImage</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// bucketManager 是 qiniu api 里操作存储空间的对象，</span></span><br><span class="line">  <span class="comment">// .fetch 方法是用来上传内容的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      bucketManager.fetch(resUrl, bucket, key, (err, res) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">expand</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> saveImage(<span class="string">''</span>, <span class="string">'hexo'</span>, <span class="string">'qiuniu_api_test.jpg'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'res'</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expand();</span><br></pre></td></tr></table></figure></p><h1 id="4-jest-测试"><a href="#4-jest-测试" class="headerlink" title="4 jest 测试"></a>4 jest 测试</h1><p>最后我们尝试使用 <code>jest</code> 来测试以 <code>Promise</code> 为基础的异步代码。<br>示例1:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">timer, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">(reslove</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// things</span></span><br><span class="line">      reslove(<span class="string">'sleep:ok'</span>);</span><br><span class="line">      <span class="keyword">if</span> (state === <span class="number">404</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'sleep:这里有个 404'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The assertion for a promise must be returned.</span></span><br><span class="line">it(<span class="string">'works with promises'</span>, () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>); <span class="comment">// ？</span></span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">1000</span>, <span class="number">200</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> expect(result).toEqual(<span class="string">'sleep:ok'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>示例1 测试的返回 <code>promise</code>示例的函数，需要设置 <code>expect.assertions(1)</code>，然后将期望函数写到 <code>.then</code> 方法中即可。<br>示例2:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asynchornous</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'测试 async/await'</span>);</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await can be used.</span></span><br><span class="line">it(<span class="string">'works with async/await'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> asynchornous(<span class="number">1000</span>);</span><br><span class="line">  expect(data).toEqual(<span class="string">'测试 async/await'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>代码同样很简单，更多的示例可以查看 <code>jest</code> 的官网文档。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul><li><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript Promise 迷你书(中文版)</a></li><li><a href="http://es6.ruanyifeng.com/#docs/async#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li><a href="https://juejin.im/post/5a113172f265da431e165a6e" target="_blank" rel="noopener">从地狱到天堂，Node 回调向 async/await 转变</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[注：以下代码都在支持 Promise 的 Node 环境中实现]&lt;br&gt;
    
    </summary>
    
    
      <category term="node，async，await，回调，promise" scheme="http://blog.ohcat.xyz/tags/node%EF%BC%8Casync%EF%BC%8Cawait%EF%BC%8C%E5%9B%9E%E8%B0%83%EF%BC%8Cpromise/"/>
    
  </entry>
  
  <entry>
    <title>WEB 前端学习指南（下）</title>
    <link href="http://blog.ohcat.xyz/2017/01/01/web-development-study-guid(2)/"/>
    <id>http://blog.ohcat.xyz/2017/01/01/web-development-study-guid(2)/</id>
    <published>2017-01-01T09:31:07.000Z</published>
    <updated>2018-05-03T00:14:11.918Z</updated>
    
    <content type="html"><![CDATA[<p>与文章的 <a href="http://blog.ohcat.xyz/2016/06/18/WEB%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%8A%EF%BC%89/">上篇</a> 相隔近 6 个月的时间，我才开始整理下篇。这 6 个月来我一直在不间歇地做运营活动的 H5 页面，写了很多重复的代码，做了很多简单的开发。因此，我还谈不上对 16 年的前端技术栈有多么深刻而有意义的解读。在这篇文章里，我没法给出富有创新的代码，我只能罗列出我学习和工作轨迹里所用到的工具与资源。<br><a id="more"></a></p><p>这篇文章的是写给进击的前端学习者，中级的前端开发（这并不意味这篇文章的内容不适合初学者，只是很多内容可能难以顾及初学者触及的深度）。那么我依然从三驾马车开始谈吧！</p><h3 id="三驾马车：HTML5-CSS3-JavaScript"><a href="#三驾马车：HTML5-CSS3-JavaScript" class="headerlink" title="三驾马车：HTML5 + CSS3 + JavaScript"></a>三驾马车：HTML5 + CSS3 + JavaScript</h3><p><strong>HMTL5</strong> 是 HTML 标准的最新演进版本。它是一个新的 HTML 语言版本包含了新的元素，属性和行为，同时包含了一系列可以被用来让 Web 站点和应用更加多样化，功能更强大的技术。从对 Web 开发人员有用这点触发，和基于它们的各自功能，可以将 HTML5 技术的资源归类成若干组：</p><ul><li>语义：能够更恰当的描述网页的内容</li><li>连通性：能够和服务器使用创新的新技术方法进行通信</li><li>离线 &amp; 存储：能够让网页在客户端本地存储以及更高效地离线运行</li><li>多媒体：使 video 和 audio 成为了 Web 中的一等公民</li><li>2D/2D 绘图 &amp; 效果，矢量图：提供更加丰富的呈现选择</li><li>性能 &amp; 集成：提供了非常显著的性能游湖和更有效的计算机硬件使用</li><li>设备访问 Device Access：能够处理各种输入和输出设备</li></ul><p>不可否认，这段解释我摘抄自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML" target="_blank" rel="noopener">MDN</a>。同时还有这个网页更详细的提供了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/%E6%BC%94%E7%A4%BA%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Web 技术示例</a>，MDN 是 Mozilla 维护的技术文档。谷歌也同样提供了 <a href="https://developers.google.cn/web/" target="_blank" rel="noopener">Web 开发的指南</a>，而且 google 提供的是具体的开发更优秀 Web 网页的方法和理论。<br><img src="http://static.ohf2e.com/20170102/Google Web.PNG" alt=""></p><p>我记得在上篇我推荐的 HTML5 参考还是 w3cschool，但现在，我认为它完全过时了，并且毫无创意。它不像 MDN 那样提供完善的技术文档和参考资源，也不会像 google 告诉你如何做出更好的 Web 网页。使用 w3cschool 也许能让你做出一两道小菜，但是使用却不能让你做出满汉全席。</p><p><strong>CSS3</strong> ，在入门后我更关注的是如何使用 less 或 sass 。这样做的目的主要是解决两个问题：</p><ol><li>避免类命名重复</li><li>实现代码的复用</li></ol><p>但是，我想这里除了添加两个官网地址，还可以提到 <a href="http://www.tuicool.com/wx/nAriimy" target="_blank" rel="noopener">CSS Modules</a>。这是一篇详细 CSS Modules 的文章 ，它同样是为了解决上面的两个问题。 </p><p>与此同时，我推荐一本关于 CSS3 的书籍——<a href="https://pan.baidu.com/s/1c2qWXf6" target="_blank" rel="noopener">《css screts》</a>。这本书给出了很多有意思的 CSS 技巧，比如：实现条纹背景，实现各种形状的 DIV 等等，我在上篇文章中有推荐过，但那时没有给出电子书的下载，上面的链接里是中文版的电子书。</p><p>当然，CSS3 里还有更有意思的新的布局方式——flexbox，我依稀记得年初刚接触这个概念的时候，在 <a href="http://caniuse.com/" target="_blank" rel="noopener">Can I Use</a> 上看到它兼容性还只到 70% 哦，但现在已经到 97%。<br><img src="http://static.ohf2e.com/20170102/flexbox.JPG?imageslim" alt=""> 它完全可以取代我们以往使用 position，float 实现的各种布局，而且代码更优雅高效。可惜我还没有找到一本书完整的介绍 flexbox，这里推荐一系列 <a href="http://www.w3cplus.com/css3/going-all-in-on-flexbox.html" target="_blank" rel="noopener">文章</a>，里面虽然介绍了使用和实践案例，但我认为并不系统，只能勉强参考着用。</p><p><strong>JavaScript</strong> 是脚本语言，从 ES6 开始变得更加强大，补充了非常多的新特性。因为我自己也还在学习中，就不讨论更多具体的语法了。但是，我想在经历过 16 年前端圈的快速变化和发展后，作为仍然在努力追赶的前端开发而言，掌握最基础的知识才能够以不变应万变。</p><p>同时，我认为大多数前端开发需要增强的技能是去掌握基于 JavaScript 的开发模式和算法。这里推荐三本书：<br><a href="https://pan.baidu.com/s/1hrZnRYO" target="_blank" rel="noopener">你不知道的 JavaScipt(上卷)</a><br><a href="https://pan.baidu.com/s/1bo8tI5T" target="_blank" rel="noopener">Javascript 设计模式与开发实践</a><br><a href="https://pan.baidu.com/s/1i5E3vXr" target="_blank" rel="noopener">数据结构与算法 Javascript 描述</a></p><h3 id="理解产品、设计"><a href="#理解产品、设计" class="headerlink" title="理解产品、设计"></a>理解产品、设计</h3><p>很多时候，程序员被认为只需要埋头写代码，只要和电脑进行沟通。那么，作为前端也不例外应该更懂 0 和 1。但实际情况可能并非如此，前端要实现的是整个产品最接近用户那一侧，给用户最直观视觉呈现和功能呈现的代码（当然，这里的前端包括了开发 Web，App，和传统的桌面应用）。</p><p>前端首先要理解的就是产品经理给出的那份原型里面的功能逻辑，然后要对用户使用产品的场景和流程达到和产品经理一样的熟练，因为前端需要从原型开始实现产品，任何不合理的需求都会使开发变得异常困难。所以，我认为前端理解产品不仅仅是理解原型，而是对产品从前端代码侧的一种解构（这句话套用到后端和数据工程师，我以为同样受用。任何一个开发都应该理解自己开发的产品。），与产品经理从用户、运营和商业等多维角度解构，重构产品是一种补充的关系。</p><p>而 “理解设计” 就是为了按照设计 1 像素还原（有些设计稿可能无法完美实现，这就是要在定稿之前避免的）。我稍微想了下这几个问题：</p><ol><li>理解设计的哪些部分？配色方案，整体布局，文案。</li><li>如何理解设计里的变化？自适应设计、响应式设计都是变化的设计。要在变化的屏幕设备里实现设计稿，那么前端就必须理解设计里变化的部分。</li><li>如何理解设计里的动态？这个指的就是 “交互” 嘛，我强行归纳到设计里了。</li></ol><p>好吧，这个命题对我而言稍微有点强人所难，其实我也正在努力学习这些，这里就只能放一些我正在关注的网站和博客了：<br><a href="https://meia.me/index.html" target="_blank" rel="noopener">美啊网</a><br><a href="http://www.uigreat.com/" target="_blank" rel="noopener">UIGREAT</a><br><a href="http://iconmoon.com/blog2/" target="_blank" rel="noopener">图月志</a></p><h3 id="前端性能和安全"><a href="#前端性能和安全" class="headerlink" title="前端性能和安全"></a>前端性能和安全</h3><p>前端的性能和安全是两个大命题，这里只能提及一二。一是我自己也要注意这方面知识和经验的积累，二是希望同样学习的前端伙伴们能够注意到这些。</p><p>前端的性能无疑是在开发过程中就要时刻注意和留心，但是性能的优化也是随着产品的复杂度才会变的重要。所以，一开始能够避开那些影响性能的地方应该就可以了。这里列出几篇文章，即提及了如何分析网页性能也给出了性能优化的方案：<br><a href="https://segmentfault.com/a/1190000005089412" target="_blank" rel="noopener">那些年我们用过的显示性能指标</a><br><a href="http://web.jobbole.com/85951/" target="_blank" rel="noopener">无线性能优化：Composite</a><br><a href="https://segmentfault.com/a/1190000007317481" target="_blank" rel="noopener">web 性能优化之：no-cache 与 must-revalidate 深入探究</a><br><a href="http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering" target="_blank" rel="noopener">Javascript 高性能动画与页面渲染</a><br><a href="https://pan.baidu.com/s/1qYVkd3m" target="_blank" rel="noopener">HTTP 权威指南</a><br><a href="https://pan.baidu.com/s/1bpzMz99" target="_blank" rel="noopener">Web 性能权威指南</a><br><a href="https://pan.baidu.com/s/1jIBJ1zw" target="_blank" rel="noopener">图解 HTTP</a></p><p>前端的安全比起性能更是要时刻注意的。然而，因为我一直没有在实际开发中深入的接触如何使前端更安全，最多就是避免常见的 xss 攻击，过滤用户输入信息等，但这一部分却是我认为极为重要的，保证网站的安全是对企业和用户必须承担的责任。<br>这里我暂时只能提供下面这本电子书：<br><a href="https://pan.baidu.com/s/1boLkXWV" target="_blank" rel="noopener">Web 前端黑客技术揭秘</a></p><h3 id="前端流行框架"><a href="#前端流行框架" class="headerlink" title="前端流行框架"></a>前端流行框架</h3><h4 id="React-还是-Vue？"><a href="#React-还是-Vue？" class="headerlink" title="React 还是 Vue？"></a>React 还是 Vue？</h4><p>坦白说，就目前而言，我并没有使用过 React 或 Vue 框架完成过项目。实际上，这两也不能称为框架，React 自己都说过它只是 MVC 中的 view。真正称的上前端框架的是 Augular、backbone 等。但是无论如何还是要选择一个，因为前端入门都快要求要懂 React 或 Vue,Augular 了。</p><p>从学习曲线上看，Vue 会比很多框架都要容易一些。首先，它的主要开发是尤雨溪（微博 ID：尤小右），所以中文文档完善（当然很多其他语言的文档也都有）；其次，Vue 比起 React,Augular 更容易理解。所以，可以先从 Vue 入门学习实践一些项目。</p><p>但最好也学一下 React。<br>……<br>果然，书到用时方恨少。</p><h3 id="JavaScript-函数式编程"><a href="#JavaScript-函数式编程" class="headerlink" title="JavaScript 函数式编程"></a>JavaScript 函数式编程</h3><p>暂时不会，以后再说。但是，听说很火的概念。有空可以了解下，因为 React 底层好像用了大量的函数式编程的思想。</p><h3 id="Linux-和数据库"><a href="#Linux-和数据库" class="headerlink" title="Linux 和数据库"></a>Linux 和数据库</h3><p>我在上篇提及了 BAE，SAE 这类 sass 可以快速部署网站应用，但实际上这样的局限很大， 并不利于前端全面认识服务器和后端语言的面貌。所以，当学有余力，不妨自己在 linux 上搭建真实的服务器环境。<br><a href="https://virtualboxes.org/images/ubuntu-server/" target="_blank" rel="noopener">linux 虚拟机镜像下载</a><br>其实在虚拟机中搭建服务器环境或者购买 阿里云，腾讯云主机服务都可以，关键是自己动手实践能够对服务器环境有所认识。</p><p><strong>数据库</strong> 是数据存储的地方，很多时候前端要理解后端接口，要根据数据库表的设计才能够理解。因此，我也自己尝试使用 mysql 和 MongoDB 写过小网站。但这部分我也研究不深，仅仅是到了通过文档能够理解数据库的读写改查。下面提供一本 MongogDB 的电子书，而 mysql 的资料目前实在寥若寒星。<br><a href="https://pan.baidu.com/s/1bpaeauz" target="_blank" rel="noopener">MongoDB 实战</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后再补充一些关于编码规范、代码测试、构建工具、协同工作、文档编写的内容。因为这部分需要懂得但不是前端的核心竞争力量（我自己的看法而已，我认为前端的核心竞争力是开篇头三节内容）</p><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>因为上篇有提及编码规范，也基本没有需要补充的，故不再单列一小节来讲了。关于代码测试，这部分我也使用不多，但是我觉得当开发复杂度高到如果 native app 的时候，代码能够自测肯定能起到事半功倍的效果。但是，目前前端圈对代码测试的要求似乎并不高。这里我只提供一些文章参考：<br><a href="http://www.jianshu.com/p/d079b9c61450" target="_blank" rel="noopener">(译) 学习如何构建自动化、跨浏览器的 JavaScript 单元测试</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDA5ODE1NQ==&amp;mid=2650432733&amp;idx=1&amp;sn=1a2042220774c2bbb70b8ed92a5d1b91" target="_blank" rel="noopener">前端可视化的测试实践</a><br><a href="https://segmentfault.com/a/1190000005090444" target="_blank" rel="noopener">【持续集成你的项目】为你的项目创建自动化测试和代码覆盖率测试</a></p><h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><p>目前 grunt 应该是会被淘汰的了，至于 gulp、webpack 或者 rollup 谁会成为前端构建工具的老大还不好说。目前我使用了 gulp 重新整理了公司项目的构建流程，具体实现可以参考 <a href="http://blog.ohcat.xyz/2016/12/29/%E6%88%91%E7%9A%84%20gulp%20%E5%B7%A5%E5%85%B7%E9%9B%86/">这篇文章</a>。</p><p>其实，能够深入理解某个构建工具并独立编写过针对具体项目的工具集以后，就可以驾驭大多数构建工具了。</p><h4 id="协同工作"><a href="#协同工作" class="headerlink" title="协同工作"></a>协同工作</h4><p>这部分我想将的是对版本管理和沟通交流的内容。我所接触到使用的版本管理工具是 git 和 svn，我想这部分只要多使用就会熟悉的，当然也要一定的理解，这里推荐一本 git 的书籍:<br><a href="https://pan.baidu.com/s/1gfaBOQZ" target="_blank" rel="noopener">Git 权威指南</a></p><p>记住要和设计，后端保持愉快的沟通交流。不要再认为前端只要写好代码、做个死宅就行了，前端简直如果桥梁一般，连接了产品各个层面的工作人员。</p><h4 id="文档编写"><a href="#文档编写" class="headerlink" title="文档编写"></a>文档编写</h4><p>最后的最后强调一遍，程序员要会写文档，前端程序员要会写好看又好用的文档。至于具体怎么写，用 markdown 就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与文章的 &lt;a href=&quot;http://blog.ohcat.xyz/2016/06/18/WEB%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;上篇&lt;/a&gt; 相隔近 6 个月的时间，我才开始整理下篇。这 6 个月来我一直在不间歇地做运营活动的 H5 页面，写了很多重复的代码，做了很多简单的开发。因此，我还谈不上对 16 年的前端技术栈有多么深刻而有意义的解读。在这篇文章里，我没法给出富有创新的代码，我只能罗列出我学习和工作轨迹里所用到的工具与资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="html5，css3，js，产品，设计，交互，数据库，git" scheme="http://blog.ohcat.xyz/tags/html5%EF%BC%8Ccss3%EF%BC%8Cjs%EF%BC%8C%E4%BA%A7%E5%93%81%EF%BC%8C%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BA%A4%E4%BA%92%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8Cgit/"/>
    
  </entry>
  
  <entry>
    <title>WEB 前端学习指南（上）</title>
    <link href="http://blog.ohcat.xyz/2016/06/18/web-development-study-guid(1)/"/>
    <id>http://blog.ohcat.xyz/2016/06/18/web-development-study-guid(1)/</id>
    <published>2016-06-18T13:11:45.000Z</published>
    <updated>2018-05-03T00:14:11.918Z</updated>
    
    <content type="html"><![CDATA[<p>我从事前端开发已经一年零六个月。从 2015 年末至今，前端开发有很多变化，这其中有我正在经历的，也有我尚未感受到的。而前端开发中的我所知道的各类知识，我想以自己绵薄之力，结合自身开发实践稍作梳理，让别人看看我踩过的坑。<br><a id="more"></a></p><p>这篇文章是写给 WEB 前端学习者，尤其是初入门的 WEB 前端开发。我写出了我自己所看到的前端开发世界里的色彩缤纷，也整理出了各个阶段能够参考学习的网站和资料。</p><h4 id="三驾马车：HTML5-CSS3-JavaScript"><a href="#三驾马车：HTML5-CSS3-JavaScript" class="headerlink" title="三驾马车：HTML5 + CSS3 + JavaScript"></a>三驾马车：HTML5 + CSS3 + JavaScript</h4><p><img src="http://upload-images.jianshu.io/upload_images/225644-7d6e116ff8afed37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTML5 + CSS3 + JavaScript"></p><p><a href="https://www.w3.org/html/ig/zh/wiki/HTML5" target="_blank" rel="noopener">HTML5</a> 是 HTML 和 XHTML 的新版本。 在 HTML5 草案 的规范中定义了可以用 HTML 和 XML 编写的单一的语言，意在解决在之前 HTML 的迭代中发现的一些问题并满足 web 应用的需求，这是以前 HTML 没有充分覆盖到的领域。这意味着 HTML5 的很多新特性是为了适应现代浏览器而增加的，这其中包括更加语义化的标签，视音频播放的 API，本地存储功能的 API 等。详情参看 <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a>。</p><p>CSS3 是 CSS 技术的升级版，目前最新版本是 CSS2.1，为 W3C 推荐标准，建议阅读 <a href="http://www.ayqy.net/blog/css2-1%E8%A7%84%E8%8C%83%E4%B8%AD%E6%96%87%E7%89%88/" target="_blank" rel="noopener">该规范的中文版</a>，这篇翻译来自 @黯羽轻扬。当然，目前 CSS3 已被大部分现代浏览器支持，而下一代 CSS4 还在开发中（有关 CSS3 开发相关请参考 <a href="https://www.w3.org/Style/CSS/）。" target="_blank" rel="noopener">https://www.w3.org/Style/CSS/）。</a></p><p><a href="http://wiki.jikexueyuan.com/project/es6/intro.html" target="_blank" rel="noopener">ECMAScript 6 (简称 ES6)</a> 是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。伴随着 Node.js 的火热，JavaScript 已经不仅仅是浏览器里面的脚本。同时，越来越多的库和框架：React(a javascript library for building user interfaces)、Flux(application architecture for buiding user interfaces)、Angular(Superheroic JavaScript MVW Framework)、Babel、Mocha…… 让前端开发更加简单。</p><h2 id="入门（html-css-js）"><a href="#入门（html-css-js）" class="headerlink" title="入门（html+css+js）"></a>入门（html+css+js）</h2><h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><p>我仍然是从前端开发的三驾马车开始讲入门的知识。毫无疑问，前端入门最快的路是打开电脑上的文本编辑工具，写下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后命名为 ‘name.html’，接着在浏览器中打开这个文件。当看到浏览器中显示出 “Hello World!” 时，一切 OK！这个桥段实在是俗了点，不过我就是从这里开始踏上前端之路的。</p><p>接下来，我要选择一个编辑器或者 IDE ，透露最终答案：我目前使用 Win10 系统，编辑器使用 sublime text3 和 Atom。对的，我使用两个编辑器，并且最终没有选择任何 IDE。但在此，我建议刚入门的开发者去尝试 WebStrom 这样功能齐全的 IDE，可以感受到代码高亮，代码自动补全，集成本地服务器测试等功能。然后，开始尝试在 sublime text3 和 Atom 中自己安装能实现 IDE 里一切所需功能的插件，以及 IDE 不具备的功能。没错，这两个编辑器完全可以定制为一个 IDE，并且更专注于编程这一件事，而不管是 web 开发者，还是 java 开发者……。当然，前提是作为一个喜欢自己折腾的开发者。</p><p>选择好一个编辑工具，如同选择一把趁手的兵器。接下来是开始学习 html5，css3，js 的时候了。这里仍然是一个很俗的桥段，打开这个网站：<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a>。开始把这个网站里的所有代码（html5,css3,js 按照这个顺序）抄写到自己的编辑器里，并且保存，然后在浏览里查看效果。如果感觉这样太枯燥了，那么可以到下面这两个视频网站去学习：<a href="http://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a> 和 <a href="http://www.imooc.com/" target="_blank" rel="noopener">慕课网</a>。下面是我推荐的几个系列视频学习课程：</p><ul><li><p><a href="http://www.jikexueyuan.com/path/html5/" target="_blank" rel="noopener">《Html5 从入门到精通》</a> 这里包含的知识已经远远超过了入门阶段，而且也对知识体系作了很好的整理。但我依然建议入门者能够从 W3school 开始一点一点写代码，而不是在视频的讲解里遨游。因为视频学习往往容易让人忽视一些基础的知识，这对于入门者而言并不是好事。</p></li><li><p><a href="http://www.imooc.com/course/list?c=html5&amp;is_easy=2" target="_blank" rel="noopener">《前端开发》</a> 这里的知识也同样超过了入门阶段所需知识。但我仍然建议入门者去看看，但不要急于动手去写其中的代码，这里的内容可以让你看到前端开发是多么有趣，以至于忘记照着 W3school 里的枯燥代码写下 ‘hello,world’ 这类的东西是多么无趣。然而， 在能够理解视频里那些酷炫好玩的东西之前，必须忍受 W3school 里呆板的代码。所以，现在先收藏这个网站，并且随时学习自己力所能及的内容。</p></li></ul><h4 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h4><p>上一部分，已经涵盖了入门 html5 + css3 + javascript 所需要的工具和参考。但是，这里依然单独用一章节来讲 CSS3。因为，如果只是学完上面提及的内容，也许你会认为 css3 能做的事情仅此而已。但是，我可以郑重的提醒你，css3 可以实现所有你能够想象的样式。当结合 js，几乎所有的动画，交互都可以实现。<br>没错，这很夸张，但是我现在却深信不疑。无论是否看完 W3school 里 CSS3 的内容，下面这个视频集合的内容都有可能让你重新认识 CSS3 ——<a href="http://www.imooc.com/learn/588" target="_blank" rel="noopener">《重拾 CSS 的乐趣》</a> 。请务必记住这个视频的作者，@CSS 魔法。因为他翻译的《css sprites》也是我重点推荐的参考书籍。</p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>当然，在看完 W3school 上 JS 的知识后，就应该看 jQuery 的知识了，仍然是在 W3school 上，同时也应该多查看 jQuery 官网。如果精力充足的话，可以去看看 <a href="http://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap</a>。因为单凭 jQuery，Bootstrap 这两个东西已足够实现一个界面优美，功能完善的网站。</p><h4 id="—-本节的扩展-—"><a href="#—-本节的扩展-—" class="headerlink" title="— 本节的扩展 —"></a>— 本节的扩展 —</h4><h6 id="（1）三个有趣的前端新应用：Hybrid-app，微信内应用，H5"><a href="#（1）三个有趣的前端新应用：Hybrid-app，微信内应用，H5" class="headerlink" title="（1）三个有趣的前端新应用：Hybrid app，微信内应用，H5"></a>（1）三个有趣的前端新应用：Hybrid app，微信内应用，H5</h6><p>从迈入移动端时代，前端技术也有了新的应用。这里主要扩展三个我认为有趣的前端的应用。</p><ul><li><p>Hybrid app：<br>一种兼顾 Web 和 Native 的一种开发模式。简单的理解就是在 app 里嵌入一个浏览器，然后访问前端开发的适配了移动端的网页。Hybrid app 要实现的是 app 与网页的数据交互。这种开发模式很好玩，让前端也能插手 app 开发。同时也让 app 开发者有兴趣接触前端技术。彼此间可以愉快的相爱相杀了……</p></li><li><p>微信内应用：<br>这个目前应该是属于国内专属的应用了。相当于 Hybrid app 模式里面已经实现了 app 的浏览器，定义好了使用微信功能的各类接口，只要开发适配微信的网页应用即可。只要掌握前端开发的基础知识，熟悉移动端开发适配的细节，然后根据微信提供的开发文档，就可以在微信 app 的开发中游刃而若有余地了。</p></li><li><p>H5:<br>这个不是 HTML5，不是！下面我会叫它 H5 专题页。首先看看它应该是什么一种形式（微信扫描二维码）：<br><img src="http://upload-images.jianshu.io/upload_images/225644-45e80f3d283f39f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="H5 应用二维码"><br>H5 专题页也是伴随微信火起来的。H5 专题页，可以简单的认为就是在微信或移动端的 PPT。在国内，做前端开发的不会做 H5 专题页是不行的！所以，在入门知识都学完以后，务必尝试开发一个或多个 H5 专题页来丰富简历。</p></li></ul><p>最后再补充一个好玩的东西：<a href="http://electron.atom.io/" target="_blank" rel="noopener">Electron</a>。Electron 可以让你使用纯 JavaScript 调用丰富的原生 API 来创造桌面应用。</p><h4 id="（2）ES6，Node-js，MongoDB，PHP，SQL……"><a href="#（2）ES6，Node-js，MongoDB，PHP，SQL……" class="headerlink" title="（2）ES6，Node.js，MongoDB，PHP，SQL……"></a>（2）ES6，Node.js，MongoDB，PHP，SQL……</h4><ul><li><p>ES6 : 接下来介绍的这些可都是很厉害的东西，作为入门者而言，没有必要马上去懂这些知识。但是，在前端进阶的路上，这里面的某些或全部都可能是要熟练掌握使用的。ES6 自不必说，JavaScript 语言的下一代标准，但我认为你没有必要一开始就去纠结了解 ES6 与 JavaScript 的区别，甚至于你完全不知道 ES6 是怎么回事，也完全不影响你作为一个合格的前端开发人员。但是，我们是有目标，有理想的。对于 JavaScript 这个开始在服务器，移动 app 端都展露头角的核武器，怎么能不去了解它的核心知识 ECMAScript？至于学习的时机，我认为是当你不再满足在浏览器上做东西，不再满足使用别人开发的库，框架的，当你不再满足只做一个前端，企图成为一名全栈工程师的时候，那么学习 ECMAScript 会是实现这一切的开始。</p></li><li><p>Node.js : “Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript Engine.”——这句话来自 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a>。意思是 Node.js 是构建于 Chrome 的 V8 JavaScript 引擎（）基础上的 JavaScript 运行环境。也就是说，它使得 JavaScript 这门程序语言可以脱离浏览器，而在服务器环境下运行。它的学习时机或许比 ES6 更早，因为我已经尝试用它在云主机上搭建 web 服务器。前后端使用同一种编程语言，这的确是一件另人兴奋的事情。</p></li><li><p>MongoDB : MongoDB,NoSQL 数据库的一种，由于我使用的不多，接触的也不是很深，这方面暂时不能提供很有价值的信息与资料。容我以后再来补上这一块的内容……</p></li><li>PHP,SQL : 我想在入门甚至于入门以后很长一段时间，凭借在 W3school 上了解到的关于它们的知识，已经足够应付开发任务。但我依然希望能够深入的学习它们，共勉之……</li></ul><p>单就入门阶段的扩展而言，我想这些知识已经现在已经足够了。但是，前端的发展很多并不是我能够想象得到的，所有关注一些公众号，微博，github，以及各种前端技术的官方网站，时刻把握动向，是非常有必要的。虽然，经验丰富的开发人员会认为新的东西往往带有风险，只有成熟，稳定的技术才能实现价值。但是，现在前端的发展太过迅猛，每一个技术都在争夺开发者。前端开发框架中火热的有 Angular、React、Vue（国内阿里团队推出的一个框架），前端构建工具中有 Grunt,Gulp,browserify,webpack，前端测试工具有 mocha,jasmine，简直如同海贼王里的大航海时代。所以，对于火热的前端，我的态度是积极投身其中，研究各种技术，进而领悟它们所展示的思路和想象，而不是等到一切尘埃落定再来选择剩下来的技术。</p><h2 id="流程和规范"><a href="#流程和规范" class="headerlink" title="流程和规范"></a>流程和规范</h2><p>网站开发不是一个人的战斗，即使是全栈工程师，也不应该一个人承担所有的任务。作为前端工程师，既要与视觉设计师、交互设计师对接设计稿、交互稿，又要与后端工程师对接数据模型。</p><p>“图难于易，为大于细”——就细节而论，与每一个角色的交流沟通过程都可以细致的整理出文章来单独讲解。因此，这里只扩展前端需要了解的知识。</p><h4 id="—-本节的扩展-—-1"><a href="#—-本节的扩展-—-1" class="headerlink" title="— 本节的扩展 —"></a>— 本节的扩展 —</h4><h4 id="PS-和-AI-的熟练使用，切图的规范，字体、svg-和-iconfont-的应用"><a href="#PS-和-AI-的熟练使用，切图的规范，字体、svg-和-iconfont-的应用" class="headerlink" title="PS 和 AI 的熟练使用，切图的规范，字体、svg 和 iconfont 的应用"></a>PS 和 AI 的熟练使用，切图的规范，字体、svg 和 iconfont 的应用</h4><p>PS 和 AI 自不必说。 MAC 上的专属设计神器 Sketch，如果有 MAC 设备建议也了解下。这里我只能提供一套不错的 PS 学习视频：<a href="http://www.uigreat.com/course/explore/uid?filter%5Btype%5D=all&amp;filter%5Bprice%5D=all&amp;filter%5BcurrentLevelId%5D=all&amp;orderBy=latest" target="_blank" rel="noopener">PS 入门教程</a>。</p><p>至于 AI，由于最近我觉得网站矢量化是一个不错的方向，所以会更深入的学习 AI，之后单独整理一篇讲网站矢量化的文章，里面再详细讲解 PS 和 AI 制作矢量图。</p><p>切图的规范，是需要设计师与前端一起商议出来。前端最好不要等到设计师自顾自的导出切图和标注图，毕竟大多数设计师不懂前端开发的逻辑。很多情况下，前端开发需要写相对距离，然而标注图上只有绝对距离，又或者相对距离的对象又完全不对，等等。总之，作为前端要清楚明白自己需要什么样的标注图，需要什么样的切图。我认为明白这两点最好的方式是自己多尝试标注、切图，找到符合自己开发逻辑的那套规范。当然，后续我也会把自己用的那一套规范整理出一篇文章。</p><p>字体的使用上，不可避免设计师会使用一些具有设计感的字体。对此，我的建议是两点：</p><ol><li><p>如果用到的特殊字体只有少部分，不是全站都要使用的，我建议是做成 SVG 图导入网站。单独提一点小 tip，在高分辨率设备逐渐普及的现在，能够做成 SVG 的图，千万不要用像素图。（这点我会在网站矢量化的研究在单独讲解）</p></li><li><p>如果是全站都要用到某些字体，比如媒体网站或者新闻阅读类网站，那么建议使 <a href="http://font-spider.org/" target="_blank" rel="noopener">字蛛</a> 字蛛通过分析本地 CSS 与 HTML 文件获取 WebFont 中没有使用的字符，并将这些字符数据从字体中删除以实现压缩，同时生成跨浏览器使用的格式。<br>这里又提到 iconfont 的应用了解，但是我也发现 iconfont 存在用户体验的问题，在一些大型网站上如 github 已经直接使用 SVG 替换 iconfont。当然作为了解 iconfont 的使用，我会在那篇网站矢量化的文章中介绍。</p></li></ol><h4 id="BAE-PHP-和-SQL-的学习使用"><a href="#BAE-PHP-和-SQL-的学习使用" class="headerlink" title="BAE,PHP 和 SQL 的学习使用"></a>BAE,PHP 和 SQL 的学习使用</h4><p>百度应用引擎（Baidu App Engine，简称 BAE）是 PaaS 平台，提供弹性、便捷、一站式的应用部署服务，支持 PHP/Java/Node.js/Python 等各种应用。只需上传应用代码，BAE 自动完成运行环境配置、应用部署、资源监控、日志收集等工作。简单的说就是把网站代码传到 BAE 分配的空间，就可以访问网站了，完全不需要自己搭建后端服务器环境，不需要自己手动配置。这是前端开发者搭建自己的网站或博客所需要的。因为我以前常用的是 BAE, 其实新浪有 SAE，阿里，腾讯也有相同的 Paas 平台。现在，我是自己在 VPS 主机上搭建服务器来运行自己的网站。至于博客，可以上一篇文章里看到介绍了 Github Page + Hexo 组合搭建博客的详细过程。</p><p>PHP 和 SQL 的学习，我还是认为学完 W3school 里的内容就够用了，但是能够越熟练越深入越好，这里再提供一些学习视频，仍然来自慕课网：<a href="http://www.imooc.com/course/list?c=be" target="_blank" rel="noopener">《后端开发》</a>。</p><p>实际上，按照现在前后端分离的开发模式来看，前端与后端最重要的沟通交流的是数据模型。一般，使用的数据格式是 XML 或 JSON ，作为前端最好根据后端设计的数据模型来设计自己的代码。因为我是自学的前端技术，在软件开发层面的知识相对薄弱，对于数据结构了解更是浅薄，所以，只要合作的后端不是很弱的那种，我一般是按照他们给出的数据模型来开发。</p><h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><p>记住这句话 “当你开始工作时，你不是在给你自己写代码，而是为后来人写代码”。大多数时候，我们面对的都是写好的代码。当以一种可维护的方式来写代码，可以让你和协作者很容易知道上段代码写到什么地方什么程度。同时，当发现以同一种方式来编写代码时，即使过很长一段时间再回头 review，也将会是一件愉快的事情。“Java 语言编码规范” 是当前很流行的关于编码规范的文档之一，它指出了编码规范如此重要的几个原因：</p><ul><li><p>软件生命周期中 80% 的成本消耗在了维护上</p></li><li><p>几乎所有的软件维护都不是它的最初作者</p></li><li><p>编码规范提高了软件的可读性，它让工程师能够快速且充分地理解新的代码</p></li><li><p>如果你将源码作为产品来发布，你需要确保它是可完整打包的，且像你创建的其他产品一样整洁。</p></li></ul><p>那么，当你意识到整洁、统一的编码规范的重要性的时候，应该如果形成自己的编码规范了。在这个问题上，我已经不再建议自己去实践尝试来得出答案。虽然实践大多数时候是得出答案的好办法，但是，对于编码规范还是直接拿来主义，把优秀的规范拿来就用：</p><ul><li><p><a href="http://coderlmn.github.io/code-standards/" target="_blank" rel="noopener">前端代码规范及实践</a> ——出自 isobar 公司的创意技术部（前端工程）</p></li><li><p><a href="http://codeguide.bootcss.com/" target="_blank" rel="noopener">编码规范 @bymod</a> ——出自 Bootstrap</p></li><li><p><a href="https://google.github.io/styleguide/htmlcssguide.xml" target="_blank" rel="noopener">Google HTML\CSS Style Guid</a> ——出自 Google</p></li><li><p><a href="https://google.github.io/styleguide/javascriptguide.xml" target="_blank" rel="noopener">Google JavaScript Style Guide</a>——出自 Google</p></li><li><p><a href="http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/index.html" target="_blank" rel="noopener">最佳编码实践 - KISSY v1.4 Documentation</a>—— 出自 阿里 KISSY</p></li></ul><h4 id="网站的优化打包发布"><a href="#网站的优化打包发布" class="headerlink" title="网站的优化打包发布"></a>网站的优化打包发布</h4><p>当我们网站开发完成，本地测试 OK 以后，还要合并压缩静态文件、使用前端镜像库、使用 CDN 进行加速、用 YSlow 或 Google Page Speed 这类的网站质量检测工具来检测线上测试站点。</p><ul><li>合并压缩静态文件：一般为了快捷有节奏的开发网站，对于静态文件 CSS，JS，图片静态资源是尽可能模块化管理，而到了上线阶段，则必须合并压缩 CSS，JS、制作 sprites 图、使用 iconfont。这样处理既减少文件体积，又减少 http 请求。具体压缩和合并方法，使用 Grunt，Gulp，Webpack 等前端自动化工具都有官方的插件来自动完成这项工作。但在前期没有接触到前端自动化构建工具前，可以使用最近微信团队推出的一个前端自动化桌面工具 <a href="https://weflow.io/" target="_blank" rel="noopener">WeFlow</a>。</li><li>使用前端镜像库：对于 jQuery，Bootstrap，这些大多数网站都有可能用到的前端工具资源，不妨使用公共的 CDN 库文件加速，这其中百度，360 这些大的互联网公司都提供的公共库。因为大部分常用网站会缓存这些常用的文件，所以当自己的网站也使用这些公共库文件时，实际是不需要重新请求获取，而是直接从用户的浏览器读取缓存文件。</li><li>使用 CDN 加速：CDN 是内容分发网络，其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。简单的理解就是把网站的静态资源传到提供 CDN 服务的云端，然后在网站中调用这些资源。</li><li>使用 Gzip 或 dfate 加速，这个是在服务器设置，暂时按下不表，等我仔细研究过后端知识再来补充。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>下一篇还在整理中。下篇会提供前端进阶的学习资料，以及思考方向等……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我从事前端开发已经一年零六个月。从 2015 年末至今，前端开发有很多变化，这其中有我正在经历的，也有我尚未感受到的。而前端开发中的我所知道的各类知识，我想以自己绵薄之力，结合自身开发实践稍作梳理，让别人看看我踩过的坑。&lt;br&gt;
    
    </summary>
    
    
      <category term="web, html, js, css, grunt, php" scheme="http://blog.ohcat.xyz/tags/web-html-js-css-grunt-php/"/>
    
  </entry>
  
  <entry>
    <title>React 实践（一）</title>
    <link href="http://blog.ohcat.xyz/2016/03/12/practice-about-react(1)/"/>
    <id>http://blog.ohcat.xyz/2016/03/12/practice-about-react(1)/</id>
    <published>2016-03-12T02:54:27.000Z</published>
    <updated>2018-05-03T00:14:11.917Z</updated>
    
    <content type="html"><![CDATA[<p>参考：《React 入门实例教程–阮一峰》、《React 学习教程–众成翻译》。React 框架入门学习摘录。<br><a id="more"></a></p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>React 的学习曲线相当陡峭，其实是入门阶段里面也是各种坑。<br>本篇开头从搭建学习用的开发环境入手。React 很多时候使用 JSX 编写。JSX是一门混合编写 JS 和 HTML 的 JS 语法糖。所以，首先我们必须编译 JSX 为浏览器能够识别的 JS。在学习之初，我是在页面中直接引用 React 的关键库和编译用的 babel 库文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/react.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/react-dom.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>前面两个文件可以在官网中下载，也可以使用 npm 下载。建议使用 npm 下载，以方便之后结合 webpack 、gulp 工具来处理 JSX。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev react react-dom</span><br></pre></td></tr></table></figure></p><p>注意，最后的一个文件是 babel 提供的在浏览器环境使用的 babel 工具。babel 既能将 ES6 转换为 ES5,同时也支持编译 JSX。这个文件我是从  <a href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js" target="_blank" rel="noopener">browser.min.js</a>下载再拷贝到本地（实践证明，从npm下载的 babel-core 里不包含这个文件）。<br>最后贴出这里的 HTML 模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/react.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/react-dom.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./libs/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// JSX</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="体验-JSX-语法"><a href="#体验-JSX-语法" class="headerlink" title="体验 JSX 语法"></a>体验 JSX 语法</h2><p>HTMl 语言直接写在 JavaScript 中，<em>不加任何引号</em>，就是 JSX 语法。JSX 的另一个基本语法规则：遇到 HTML 标签的（以 &lt;&gt;&lt;/&gt; 标签对包裹），就用 HTML 规则解析；遇到代码块（以 {} 包裹），就用 JavaScript 解析。如以下代码（如无特殊说明，之后的代码块都是写在<code>&lt;scirpt type=&quot;text/bable&quot;&gt;&lt;/script&gt;</code>中的）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Emily'</span>, <span class="string">'Kate'</span>];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    names.map(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('example')</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure></p><h2 id="简单搭建学习用的-gulp-工具箱"><a href="#简单搭建学习用的-gulp-工具箱" class="headerlink" title="简单搭建学习用的 gulp 工具箱"></a>简单搭建学习用的 gulp 工具箱</h2><p>现在只使用 gulp 工具和 browser-sync 来实现文件的热加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev gulp browser-sync</span><br></pre></td></tr></table></figure></p><p>安装完成后，在项目目录下面添加 gulpfile.js 文件。里面的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>).create();</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'server'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: <span class="string">'./src'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.watch(<span class="string">'./src/*.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(file.path + <span class="string">'is changed __'</span>);</span><br><span class="line">        browserSync.reload(); <span class="comment">// 一旦监视文件修改，就刷新浏览器</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 的组件是网页或 spa 里完成最小功能的一部分代码，这部分代码会包含该组件的基本功能，视觉样式和交互能力。使用 React 开发，首先就需要将产品切割成一个又一个组件，然后，将它们拼装成产品。下面的代码定义了一个 HelloMessage 组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloMessage = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>接下来看怎么使用这个组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage name=<span class="string">"John"</span> /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>然后在 power shell(window 10 ) 运行 <code>gulp server</code>。在打开的网页中应该显示 “Hello,John”。<br>注意，组件类的命名使用双驼峰方式，并且每一个组件类只能有一个顶层的标签。</p><h3 id="React-创建组件的三种方法"><a href="#React-创建组件的三种方法" class="headerlink" title="React 创建组件的三种方法"></a>React 创建组件的三种方法</h3><p>stateless function VS creatClass VS ES6 Class<br>出于不同的原因，React 先后出现了三种定义 react 组件的方式。分别是：</p><ol><li>函数式定义的无状态组件(stateless function)</li><li>es5 原生的 React.creatClass 定义的组件</li><li>es6 形式的 extends React.Componet 定义的组件</li></ol><h4 id="1-无状态函数式组件"><a href="#1-无状态函数式组件" class="headerlink" title="1. 无状态函数式组件"></a>1. 无状态函数式组件</h4><p>无状态函数式组件式为了创建纯展示组件，这类组件只负责根据传入的 props 来展示，不涉及到要 state 的操作。无状态函数式组件表现为一个只带有 render 方法的组件类，通过函数形式或 ES6 arrow function 的形式创建。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloComponent</span>(<span class="params">props, context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloComponent</span> <span class="attr">name</span>=<span class="string">"John"</span>) /&gt;</span>, </span></span><br><span class="line"><span class="xml">document.getElementById('content'));</span></span><br></pre></td></tr></table></figure></p><p>细节待续……</p><h4 id="2-React-creatClass-定义的组件"><a href="#2-React-creatClass-定义的组件" class="headerlink" title="2.React.creatClass 定义的组件"></a>2.React.creatClass 定义的组件</h4><p><code>React.createClass</code> 是 react 刚开始推荐的创建组件的方式，也是 es5 原生的 javascript 实现 React 组件，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> InputControl = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;  <span class="comment">// 定义传入 props 中的属性各种类型</span></span><br><span class="line">        initialValue: React.PropTypes.string</span><br><span class="line">    &#125;,</span><br><span class="line">    defaultPorps: &#123;  <span class="comment">// 组件默认的 props 对象</span></span><br><span class="line">        initialValue: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置 initial state</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 组件相关状态对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            text: <span class="keyword">this</span>.props.initialValue || <span class="string">'placeholder'</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Type something:</span><br><span class="line">                &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value= &#123;<span class="keyword">this</span>.state.text&#125; /&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">InputControl</span> /&gt;</span>, document.getElementById('content'));</span></span><br></pre></td></tr></table></figure></p><p>该方式创建的组件会被实例化，可以访问组件的生命周期方法。</p><h4 id="3-ES6-形式的创建组件"><a href="#3-ES6-形式的创建组件" class="headerlink" title="3. ES6 形式的创建组件"></a>3. ES6 形式的创建组件</h4><p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="comment">// 设置 intitial state</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            text: props.initialValue || <span class="string">'placeholder'</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ES6 类中函数必须手动绑定</span></span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;Type something:</span><br><span class="line">                &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.text&#125;/&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">InputControl.propTypes = &#123;</span><br><span class="line">    initialValue: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line">InputControl.defaultProps = &#123;</span><br><span class="line">    initialValue: <span class="string">''</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使用组件的时候，不需要 new 实例化。</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">InputControl</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>));</span><br></pre></td></tr></table></figure></p><p>这种方式和之前 ES5 的差别比较大，也是目前 React 比较推荐的写法。delay……</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>一个组件就是一个状态机：对于特定的输入，它总会返回一致的输出。React 为组件提供了生命周期钩子函数去响应不同的时期——创建、存在期及销毁。</p><ul><li>Mounting: 已插入真实的 DOM</li><li>Updating: 正在重新渲染</li><li>Unmounting: 移除真实的 DOM</li></ul><p>Mounting 和 Updating 时期都有两个方法：componentWillMount，componentDidMount 和 componentWillUpdate，componentDidUpdate。<br>同时，Mounting 时期还分为两种情况，一种是组件第一次被 Mounting，一种是后续被 Mounting。它们都有 getInitialState 方法，但是初次 mounting 还有一个 getDefaultProps 方法。<br>Updating 时期 还有两个特殊方法 componentWillReceiveProps，shouldComponentUpdate。  Unmounting 只有一个方法：componentWillUnmount。<br>同时可以参考以下图片来理解组件的生命周期：<img src="http://o92qtbg1t.bkt.clouddn.com/component-1-1.PNG" alt="component 生命周期" title="组件生命周期里调用的方法顺序"><br>接下来在代码中看看这些方法的调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LogStatus = React.createClass(&#123;</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件开始实例化……设置默认 props'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件开始实例化……设置默认 state'</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件即将实例化……'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillReceiveProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件即将初始化……并更新 state'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentWillUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件即将更新……'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onTest: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">state, props</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i = state.num + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">num</span>: i&#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> num = <span class="keyword">this</span>.state.num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onTest&#125;</span>&gt;</span>this.props.text</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件实例化完成……'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    componentDidUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件更新完成……'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;LogStatus text=<span class="string">"组件第一次实例化"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">LogStatus</span>&gt;</span></span>, </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;LogStatus text=<span class="string">"组件第二次实例化"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">LogStatus</span>&gt;</span></span>,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content2'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>代码里基本演示了各个阶段调用的方法。但这是 ES5 是的生命周期函数，然而，现在，React 更推荐的 ES6 写法，对生命周期函数也进行了调整。<br>修改如下图：<img src="http://upload-images.jianshu.io/upload_images/225644-b7435e69761f6339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ES6 组件的生命周期函数"></p><p>参考代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            str : <span class="string">'s'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Initial render"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"component will mount"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"component will receive props"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"should component update"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"component did updates"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will unmount'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTheState() &#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.str === <span class="string">'s'</span>)&#123;</span><br><span class="line">            s = <span class="string">"HELLO"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            str: s</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forceItUpdate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"render"</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;span&gt;&#123;<span class="string">"Props:"</span>&#125;&lt;h2&gt;&#123;<span class="built_in">parseInt</span>(<span class="keyword">this</span>.props.num)&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>span&gt;</span><br><span class="line">                &lt;br&gt;<span class="xml"><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span></span><br><span class="line">                &lt;span&gt;&#123;<span class="string">"state:"</span>&#125;&lt;h2&gt;&#123;<span class="keyword">this</span>.state.str&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Container extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">        super(props);</span></span><br><span class="line"><span class="regexp">        this.state = &#123;</span></span><br><span class="line"><span class="regexp">            num: Math.random() * 100</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    propsChange() &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">            num: Math.random() * 100</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    setLifeCycleState() &#123;</span></span><br><span class="line"><span class="regexp">        this.refs.rLifeCycle.setTheState();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    forceLifeCycleUpdate() &#123;</span></span><br><span class="line"><span class="regexp">        this.refs.rLifeCycle.forceItUpdate();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    parentForceUpdate() &#123;</span></span><br><span class="line"><span class="regexp">        this.forceUpdate();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;a href="javascript:;" className="weui_btn weui_btn_primary" </span></span><br><span class="line"><span class="regexp">                onClick=&#123;this.propsChange.bind(this)&#125;&gt;propsChange</span></span><br><span class="line"><span class="regexp">                &lt;/</span>a&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;a href=<span class="string">"javascript:;"</span> className=<span class="string">"weui_btn weui_btn_primary"</span> </span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.setLifeCycleState.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">                setState</span><br><span class="line">                &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                &lt;br/</span>&gt;</span><br><span class="line">                &lt;a href=<span class="string">"javascript:;"</span> className=<span class="string">"weui_btn weui_btn_primary"</span> </span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.forceLifeCycleUpdate.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">                forceUpdate</span><br><span class="line">                &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                &lt;br/</span>&gt;</span><br><span class="line">                &lt;a href=<span class="string">"javascript:;"</span> className=<span class="string">"weui_btn weui_btn_primary"</span> </span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.parentForceUpdate.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">                parentForceUpdateWithoutChange</span><br><span class="line">                &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">                &lt;br/</span>&gt;</span><br><span class="line">                &lt;LifeCycle ref=<span class="string">"rLifeCycle"</span> num=&#123;<span class="keyword">this</span>.state.num&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">LifeCycle</span>&gt;</span></span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Container&gt;&lt;/</span>Container&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>没有找到销毁一个 React component 的方法，所以，componentWillUnmount() 没有使用。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>在 React,数据的流向是单向的，从父节点传递到子节点。在之前的代码已反复使用了数据流里相关的两个参数 props, state。</p><h3 id="1-Props"><a href="#1-Props" class="headerlink" title="1.Props"></a>1.Props</h3><p>Props 就是 properties 的缩写。它可以把任意类型的数据传递给组件。<br>可以在挂载组件的时候设置它的 props:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var MyTitle = React.createClass(&#123;</span><br><span class="line">    render: function()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyTitle title=&quot;hello，world&quot;&gt;&lt;/MyTitle&gt;,</span><br><span class="line">    document.getElementById(&apos;content&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上面代码中，在挂载时传入 <code>title=&quot;hello,world&quot;</code>的参数，这里的参数都会添加到 props 中。<br>另外可以通过调用组件实例的 serProps 方法（很少需要这样做）来设置其 props:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listSurveys = React.render(</span><br><span class="line">    &lt;ListSurveys /&gt;, <span class="built_in">document</span>.querySlector(<span class="string">'body'</span>)</span><br><span class="line">    );</span><br><span class="line">listSurveys.serProps(&#123;<span class="attr">surveys</span>: surveys&#125;);</span><br></pre></td></tr></table></figure></p><p>你只能在子组件或者在组件树外调用 setProps。千万别使用 this.setProps 或者直接修改 this.props。</p><h4 id="PropTypes"><a href="#PropTypes" class="headerlink" title="- PropTypes"></a>- PropTypes</h4><p>通过在组件中定义一个配置对象，React提供了一中验证 props 的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SurveyTableRow = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;</span><br><span class="line">        survey: React.PropTypes.shape(&#123;</span><br><span class="line">            id: React.PropTypes.number.isRequired</span><br><span class="line">            &#125;).isRequired,</span><br><span class="line">        onClick: React.PropTypes.func</span><br><span class="line">    &#125;,</span><br><span class="line">    ……</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>组件初始化的时候，如果传递的属性和 propTypes 不匹配，则会打印一个 console.warn 日志。<br>如果是可选的配置，则可以去掉 .isRequired。<br>注意，在应用中使用的 propTypes 并不是强制的，但这提供了一种描述组件 API 的方式。<br>但在 ES6 的写法中，是单独将 propTypes 绑定在组件类中了，写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">CustomButton.propTypes = &#123;</span><br><span class="line">  name: React.PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="- getDefaultProps"></a>- getDefaultProps</h4><p>如果要添加属性的默认值，可以使用 getDefaultProps 函数。不过，这应该只针对那些非必要属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SurveyTable = React.createClass(&#123;</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            surveys: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>注意，getDefaultProps 并不是在组件实例化的时候被调用的，而是在 React.createClass 调用的时候调用的，返回值会被缓存起来，所以，不能在 这个函数里调用任何特定的实例数据。下面再看看 ES6 的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomButton.defaultProps = &#123;</span><br><span class="line">  color: <span class="string">'blue'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-State"><a href="#2-State" class="headerlink" title="2.State"></a>2.State</h3><p>每个 React 组件都有自己的 state,但是 state 只存在于组件的内部。state 是用来确定和修改组件的状态的。一个组件与用户交互的过程中，会根据用户的输入不断更新状态，实际就是依靠 state 来更新的。具体实现看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CountryDropdown = React.createClass(&#123;</span><br><span class="line">    getInitialState : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            showOptions: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> options;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.showOptions)&#123;</span><br><span class="line">            options = (</span><br><span class="line">                &lt;ul className=<span class="string">'options'</span>&gt;</span><br><span class="line">                    &lt;li&gt;United States <span class="keyword">of</span> America&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;li&gt;New Zealand&lt;/</span>li&gt;</span><br><span class="line">                    &lt;li&gt;Denmark&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"dropdown"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">            &lt;label&gt;Choose a country &lt;<span class="regexp">/lable&gt;.&#123;options&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            );</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)&#125;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            showOptions: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>注意，不能直接使用 this.state 来修改 state, 而是要使用 this.setState 来修改。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 事件本质上和 JavaScript 事件一样。所有事件在命名上也和原生 JavaScript 规范一致，并且会在相同的请将下被触发。但是，React 绑定事件处理器的语法和 直接在 HTML 绑定事件的语法类似。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"btn btn-save"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">onClick</span>=<span class="string">&#123;this.handleSaveClicked&#125;</span>&gt;</span> Save <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户点击按钮时，handleSaveClicked()会被调用。事实上，这种写法虽然和 HTML 内联事件写法类似，其实在底层实现上并没有使用 HTML 的 onClick 属性。React 只是用这个写法来绑定事件处理器，其内部则按需高效地维护着事件处理器。<br>通常当一个事件被触发以后，会有一个事件对象被传递给事件处理函数中。打印出事件对象信息如下：<img src="http://upload-images.jianshu.io/upload_images/225644-70e6363384361d78.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：《React 入门实例教程–阮一峰》、《React 学习教程–众成翻译》。React 框架入门学习摘录。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://blog.ohcat.xyz/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Page搭建轻博客</title>
    <link href="http://blog.ohcat.xyz/2016/03/05/use-gitHub-pages-to-build-a-blog/"/>
    <id>http://blog.ohcat.xyz/2016/03/05/use-gitHub-pages-to-build-a-blog/</id>
    <published>2016-03-05T02:54:27.000Z</published>
    <updated>2018-05-03T00:14:11.917Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Page</a> 是 Github 提供的静态网站系统，而Hexo则是轻量级的博客框架。两者的组合可以很方便的搭建起自己的博客网站，并更新文章。<br><a id="more"></a></p><h2 id="选择-Github-Page"><a href="#选择-Github-Page" class="headerlink" title="选择 Github Page"></a>选择 Github Page</h2><p> Github Page 有什么特点</p><ul><li>配置简单</li><li>无需自己搭建服务器，无需购买域名</li><li>使用标记语言，比如 Markdown</li><li>Github 限制每个站点只有 300M 空间，因为 Github 提供 Github Page 服务本意是提供一个能快速搭建更新的静态网站给用户介绍自己的项目</li><li>评论和分享等可以使用插件实现</li></ul><h2 id="安装准备软件"><a href="#安装准备软件" class="headerlink" title="安装准备软件"></a>安装准备软件</h2><p>本机使用 window 10 操作系统，所有软件安装都是在 window 系统下。首先安装如下软件：</p><ul><li>git <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a></li><li>node.js <a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></li></ul><h2 id="使用-Github-Page-建立博客"><a href="#使用-Github-Page-建立博客" class="headerlink" title="使用 Github Page 建立博客"></a>使用 Github Page 建立博客</h2><p>在 Github 上注册账号，然后使用 Github Page 建立博客。<br>GitHub Pages 分两种，一种是使用 GitHub 用户名建立的 username.github.io 这样的用户&amp;组织页（站），另一种是依附项目的 pages。<br>建立个人博客是用的第一种，建立域名为 username.github.io 的站点。</p><h4 id="1-在-Github-上建立仓库："><a href="#1-在-Github-上建立仓库：" class="headerlink" title="1. 在 Github 上建立仓库："></a>1. 在 Github 上建立仓库：</h4><p>登录 Github，在 Github 首页，点击页面右下角「New」</p><p><img src="http://7xifdy.com1.z0.glb.clouddn.com/hexo/1/1.png" alt="1.png"></p><h4 id="2-填写项目信息"><a href="#2-填写项目信息" class="headerlink" title="2. 填写项目信息"></a>2. 填写项目信息</h4><p><strong>project name：</strong> username.github.io<br><strong>description：</strong> introduce your blog<br>注：Github Pages 的 Repository 必须使用 Github 的账户名。</p><h4 id="3-点击「Create-Repository」-完成创建。"><a href="#3-点击「Create-Repository」-完成创建。" class="headerlink" title="3. 点击「Create Repository」 完成创建。"></a>3. 点击「Create Repository」 完成创建。</h4><p><img src="http://7xifdy.com1.z0.glb.clouddn.com/hexo/1/2.png" alt="2.png"></p><h2 id="安装、配置、使用-Hexo"><a href="#安装、配置、使用-Hexo" class="headerlink" title="安装、配置、使用 Hexo"></a>安装、配置、使用 Hexo</h2><h4 id="1-安装-Hexo"><a href="#1-安装-Hexo" class="headerlink" title="1. 安装 Hexo"></a>1. 安装 Hexo</h4><p>打开 Git Bash, 使用 npm 安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></p><p>因为 npm 在国内不好用的原因，所有建议使用淘宝的源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo disturl=http://registry.npm.taobao.org/mirrors/node --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>在这一过程遇到的其他问题可以参阅这篇文章 <a href="http://chitanda.me/2015/06/11/tips-for-setup-hexo/" target="_blank" rel="noopener">hexo博客搭建时遇到的一些问题</a></p><h4 id="2-部署-Hexo"><a href="#2-部署-Hexo" class="headerlink" title="2. 部署 Hexo"></a>2. 部署 Hexo</h4><p>新建一个 <strong> hexo </strong> 文件夹，在 Git Bash 中进入 <strong>hexo</strong>文件夹，使用下面命令初始化 Hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>Hexo 随后会自动在目标文件夹创建网站的所有文件。<br>目前，已经搭建起本地的 hexo 博客，执行以下命令，然后到浏览器输入 localhost:4000 就可以看到自己的博客网站了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>更多 hexo 命令和使用可以参看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo 官网</a></p><h2 id="hexo-关联-Github-Page"><a href="#hexo-关联-Github-Page" class="headerlink" title=" hexo  关联 Github Page"></a><strong> hexo </strong> 关联 Github Page</h2><p>在 <strong>hexo</strong> 文件夹的根目录下找到 _config.yml ，并打开。 在配置文件的中找到 <strong>deploy</strong>配置项，配置内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>注意修改仓库地址中的 username</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Page&lt;/a&gt; 是 Github 提供的静态网站系统，而Hexo则是轻量级的博客框架。两者的组合可以很方便的搭建起自己的博客网站，并更新文章。&lt;br&gt;
    
    </summary>
    
    
      <category term="Github Hexo" scheme="http://blog.ohcat.xyz/tags/Github-Hexo/"/>
    
  </entry>
  
</feed>
